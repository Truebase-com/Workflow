
namespace Moduless
{
	
	/** */
	type VerifierFn = () => boolean;
	
	// This value is replaced before it's sent down from
	// the server. The naming of it is therefore intentional.
	const __wsPort__ = 10002;
	const ws = new WebSocket("ws://localhost:" + __wsPort__, "json");
	
	// Stores all cover functions loaded into the browser.
	const coverRepository: { [name: string]: Function; } = {};
	
	const verifierReg = /^\(\)\s*=>/;
	const stackReg = /^\s*at\s.+\s\(.+:\d+\)$/;
	
	/**
	 * This function is called from the code that is injected 
	 * in the HTML page generated by the moduless server.
	 */
	export function addCover(coverFn: Function)
	{
		const coverName = coverFn.name;
		coverRepository[coverName] = coverFn;
	}
	
	/**
	 * Executes the test with the specified function name.
	 */
	export async function runCover(coverFunctionName: string)
	{
		const coverFn = coverRepository[coverFunctionName];
		if (typeof coverFn !== "function")
			throw new Error("Unknown cover function: " + coverFunctionName);
		
		let coverReturnValue: 
			VerifierFn | 
			VerifierFn[] |
			Promise<VerifierFn | VerifierFn[]> |
			undefined;
		
		try
		{
			coverReturnValue = coverFn();
		}
		catch (e)
		{
			const message = createExceptionMessage(coverFunctionName, e);
			debugger;
			return message;
		}
		
		if (coverReturnValue === undefined)
			return new EndCoverMessage(coverFunctionName, "", [], []);
		
		const maybeArray = coverReturnValue instanceof Promise ?
			await coverReturnValue :
			coverReturnValue;
		
		const verifierFns = Array.isArray(maybeArray) ? 
			maybeArray :
			[maybeArray];
		
		const verifications: IVerificationResult[] = [];
		
		for (const verifierFn of verifierFns)
		{
			const verifierFnText = String(verifierFn);
			
			if (typeof verifierFn !== "function" || !verifierReg.test(verifierFnText))
			{
				return createExceptionMessage(
					coverFunctionName,
					new Error("Returned verifiers are expected to be arrow functions."));
			}
			
			let result: any;
			
			try
			{
				result = verifierFn();
			}
			catch (e)
			{
				const message = createExceptionMessage(coverFunctionName, e);
				debugger;
				return message;
			}
			
			if (![true, false, null, void 0].includes(result))
			{
				const returned = 
					(result !== result) ? "NaN" :
					Array.isArray(result) ? "array (length=" + result.length + ")" :
					typeof result === "string" ? `string ("${result.slice(0, 100)}")` :
					typeof result === "number" ? `number (${result})` :
					typeof result === "bigint" ? `bigint (${result})` :
					typeof result === "symbol" ? `symbol (${result.description || "no description"})` :
					typeof result === "function" ? `function (${result.name})` :
					typeof result === "object" ? `object (${result.constructor.name})` :
					"(unknown)";
				
				return createExceptionMessage(
					coverFunctionName,
					new Error("Verifier function returned an unexpected " + returned));
			}
			
			const expression = verifierFn.toString()
				.trim()
				.replace(verifierReg, "")
				.trim();
			
			verifications.push({ expression, pass: !!result });
		}
		
		return new EndCoverMessage(coverFunctionName, "", [], verifications);
	}
	
	/**
	 * 
	 */
	function createExceptionMessage(coverFunctionName: string, error: Error)
	{
		const stackLines = (error.stack || "")
			.split("\n")
			.filter(line => stackReg.test(line));
		
		return new EndCoverMessage(
			coverFunctionName,
			error.message,
			stackLines,
			[]);
	}
	
	/**
	 * 
	 */
	async function handleStartCoverMessage(coverFunctionName: string)
	{
		const endCoverMessage = await runCover(coverFunctionName);
		ws.send(endCoverMessage.toString());
	}
	
	ws.addEventListener("message", ev =>
	{
		const message = Message.parse(ev.data);
		
		if (message instanceof StartCoverMessage)
			handleStartCoverMessage(message.coverName);
		
		else if (message instanceof ReloadMessage)
			window.location.reload();
		
		else
			throw new Error("Unsupported message: " + message.constructor.name);
	});
	
	/**
	 * Tracks the width, height, and position of the browser window on the
	 * screen, and reports this information back to the VS Code extension.
	 */
	(function streamWindowMetrics()
	{
		let resizeQueued = false;
		let lastScreenX = window.screenX;
		let lastScreenY = window.screenY;
		let lastWidth = window.outerWidth;
		let lastHeight = window.outerHeight;
		
		//
		function maybeReportWindowMetrics()
		{
			if (lastScreenX === window.screenX &&
				lastScreenY === window.screenY &&
				lastWidth === window.outerWidth &&
				lastHeight === window.outerHeight)
				return;
			
			const msg = new WindowMetricsMessage(
				lastScreenX = window.screenX,
				lastScreenY = window.screenY,
				lastWidth = window.outerWidth,
				lastHeight = window.outerHeight);
			
			ws.send(msg.toString());
		}
		
		window.addEventListener("resize", () =>
		{
			if (resizeQueued)
				return;
			
			setTimeout(() =>
			{
				maybeReportWindowMetrics();
				resizeQueued = false;
			},
			100);
		});
		
		// Unfortunately there's no browser event that triggers
		// when the browser window is moved around on the screen
		// without being resized. And so we have to just poll for this.
		setInterval(maybeReportWindowMetrics, 500);
	})();
}
