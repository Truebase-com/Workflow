
const testRepository: { [name: string]: Function; } = {};

namespace Moduless
{
	/** */
	type VerifierFn = () => boolean;
	
	// This value is replaced before it's sent down from
	// the server. The naming of it is therefore intentional.
	const __wsPort__ = 10002;
	const ws = new WebSocket("ws://localhost:" + __wsPort__, "json");
	
	const verifierReg = /^\(\)\s*=>/;
	const stackReg = /^\s*at\s.+\s\(.+:\d+\)$/;
	
	/**
	 * This function is called from the code that is injected 
	 * in the HTML page generated by the moduless server.
	 */
	export function addCase(caseFn: Function)
	{
		const testName = caseFn.name;
		testRepository[testName] = caseFn;
	}
	
	/**
	 * Executes the test with the specified function name.
	 */
	export async function runCase(caseFunctionName: string)
	{
		const caseFn = testRepository[caseFunctionName];
		if (typeof caseFn !== "function")
			throw new Error("Unknown case function: " + caseFunctionName);
		
		let caseReturnValue: 
			VerifierFn | 
			VerifierFn[] |
			Promise<VerifierFn | VerifierFn[]> |
			undefined;
		
		try
		{
			caseReturnValue = caseFn();
		}
		catch (e)
		{
			const message = createExceptionMessage(caseFunctionName, e);
			debugger;
			return message;
		}
		
		if (caseReturnValue === undefined)
			return new EndCaseMessage(caseFunctionName, "", [], []);
		
		const maybeArray = caseReturnValue instanceof Promise ?
			await caseReturnValue :
			caseReturnValue;
		
		const verifierFns = Array.isArray(maybeArray) ? 
			maybeArray :
			[maybeArray];
		
		const verifications: IVerificationResult[] = [];
		
		for (const verifierFn of verifierFns)
		{
			const verifierFnText = String(verifierFn);
			
			if (typeof verifierFn !== "function" || !verifierReg.test(verifierFnText))
			{
				return createExceptionMessage(
					caseFunctionName,
					new Error("Returned verifiers are expected to be arrow functions."));
			}
			
			let result: any;
			
			try
			{
				result = verifierFn();
			}
			catch (e)
			{
				const message = createExceptionMessage(caseFunctionName, e);
				debugger;
				return message;
			}
			
			if (![true, false, null, void 0].includes(result))
			{
				const returned = 
					(result !== result) ? "NaN" :
					Array.isArray(result) ? "array (length=" + result.length + ")" :
					typeof result === "string" ? `string ("${result.slice(0, 100)}")` :
					typeof result === "number" ? `number (${result})` :
					typeof result === "bigint" ? `bigint (${result})` :
					typeof result === "symbol" ? `symbol (${result.description || "no description"})` :
					typeof result === "function" ? `function (${result.name})` :
					typeof result === "object" ? `object (${result.constructor.name})` :
					"(unknown)";
				
				return createExceptionMessage(
					caseFunctionName,
					new Error("Verifier function returned an unexpected " + returned));
			}
			
			const expression = verifierFn.toString()
				.trim()
				.replace(verifierReg, "")
				.trim();
			
			verifications.push({ expression, pass: !!result });
		}
		
		return new EndCaseMessage(caseFunctionName, "", [], verifications);
	}
	
	/** */
	function createExceptionMessage(caseFunctionName: string, error: Error)
	{
		const stackLines = (error.stack || "")
			.split("\n")
			.filter(line => stackReg.test(line));
		
		return new EndCaseMessage(
			caseFunctionName,
			error.message,
			stackLines,
			[]);
	}
	
	/**
	 * 
	 */
	async function handleStartCaseMessage(caseFunctionName: string)
	{
		const endCaseMessage = await runCase(caseFunctionName);
		ws.send(endCaseMessage.serialize());
	}
	
	ws.addEventListener("message", ev =>
	{
		const message = Message.parse(ev.data);
		
		if (message instanceof StartCaseMessage)
			handleStartCaseMessage(message.caseName);
		
		else if (message instanceof ReloadMessage)
			window.location.reload();
		
		else
			throw new Error("Unsupported message: " + message.constructor.name);
	});
}
